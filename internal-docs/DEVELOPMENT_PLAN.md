# Kumiki 開発計画

## 概要

このドキュメントは、MVP_ARCHITECTURE.mdに基づいて立案したKumikiプロジェクトの開発計画です。

## 開発フェーズ

### 実装順序の方針

1. **validateコマンド** - JSON構造の検証機能を最初に実装
2. **previewコマンド** - 各シーンの静止画像生成
3. **generateコマンド** - 動画の生成と結合

### フェーズ1: Validateコマンドの実装（最優先）

#### 1.1 プロジェクトの初期セットアップ
- [ ] package.jsonの作成
  - TypeScript、ESM対応の設定
  - 必要な依存関係の定義（commander, joi/zod, winston）
- [ ] tsconfig.jsonの設定
  - strict modeの有効化
  - ESM対応の設定

#### 1.2 基本的なディレクトリ構造
- [ ] 必要最小限のディレクトリ作成
  ```
  src/
  ├── core/
  │   ├── parser.ts
  │   └── validator.ts
  ├── types/
  │   └── index.ts
  ├── utils/
  │   ├── logger.ts
  │   └── errors.ts
  ├── commands/
  │   └── validate.ts
  └── cli.ts
  ```

#### 1.3 型定義とバリデーション
- [ ] JSON構造の型定義（KumikiProject, Scene等）
- [ ] Joi/Zodを使用したスキーマ定義
- [ ] parser.ts - JSON読み込みと基本的な解析
- [ ] validator.ts - 詳細な検証ロジック
- [ ] エラーメッセージの整備

#### 1.4 Validateコマンド
- [ ] validate.ts - コマンドの実装
- [ ] cli.ts - CLIエントリーポイント（validateのみ）
- [ ] 基本的なログ出力とエラーハンドリング

### フェーズ2: Previewコマンドの実装（高優先度）

#### 2.1 シーンレンダリング基盤
- [ ] ディレクトリ構造の拡張
  ```
  src/
  ├── scenes/
  │   ├── base.ts
  │   ├── factory.ts
  │   ├── text.ts
  │   └── image.ts
  ├── services/
  │   └── puppeteer.ts
  ```

#### 2.2 BaseSceneとFactory
- [ ] base.ts - 基底クラス（静止画生成メソッド）
- [ ] factory.ts - シーン生成のファクトリー

#### 2.3 静止画レンダラー
- [ ] puppeteer.ts - ブラウザ管理とスクリーンショット
- [ ] text.ts - テキストシーンのHTML/CSS生成とPNG出力
- [ ] image.ts - 画像シーンの処理とPNG出力

#### 2.4 Previewコマンド
- [ ] preview.ts - 各シーンの静止画生成コマンド
- [ ] CLI拡張 - previewコマンドの追加
- [ ] 出力ディレクトリ管理

### フェーズ3: Generateコマンドの実装（中優先度）

#### 3.1 動画処理基盤
- [ ] ディレクトリ構造の完成
  ```
  src/
  ├── services/
  │   ├── ffmpeg.ts
  │   └── audio.ts
  ├── effects/
  │   ├── animations.ts
  │   └── transitions.ts
  ├── core/
  │   └── renderer.ts
  ```

#### 3.2 FFmpeg統合
- [ ] ffmpeg.ts - FFmpegラッパー実装
  - 基本的なコマンド実行
  - エラーハンドリング
  - 進捗表示

#### 3.3 シーンの動画化
- [ ] TextSceneRenderer - PNG → MP4変換
- [ ] ImageSceneRenderer - 画像 → MP4変換
- [ ] VideoSceneRenderer - 動画の切り出しと変換

#### 3.4 アニメーション・トランジション
- [ ] animations.ts - 基本的なアニメーション（fade-in等）
- [ ] transitions.ts - シーン間のトランジション

#### 3.5 動画結合
- [ ] renderer.ts - メインレンダリング制御
  - シーンの並列処理
  - 動画の結合
  - 音声の追加（オプション）

#### 3.6 Generateコマンド
- [ ] generate.ts - 完全な動画生成コマンド
- [ ] CLI完成 - 全コマンドの統合
- [ ] 進捗表示とエラー処理

### フェーズ4: 品質向上（低優先度）

#### 5.1 テスト
- [ ] ユニットテスト（Vitest）
  - 各モジュールの単体テスト
  - モックを使用した外部依存の分離
- [ ] 統合テスト
  - エンドツーエンドのワークフロー
  - 実際のFFmpeg実行を含むテスト

#### 5.2 ドキュメント
- [ ] APIドキュメント
- [ ] 使用方法ガイド
- [ ] アーキテクチャドキュメント

#### 5.3 サンプル
- [ ] 基本的なテキスト動画サンプル
- [ ] 画像スライドショーサンプル
- [ ] 複雑なアニメーションサンプル

## 技術的な考慮事項

### パフォーマンス
- p-queueを使用した並列処理の実装
- 大きなファイルのストリーミング処理
- メモリ効率的な実装

### エラーハンドリング
- 各レイヤーでの適切なエラーキャッチ
- ユーザーフレンドリーなエラーメッセージ
- デバッグモードでの詳細ログ

### 拡張性
- プラグインシステムの基盤準備
- フック機構の実装準備
- 新しいシーンタイプの追加を容易にする設計

## マイルストーン

### MVP（最小実行可能製品）
- 基本的な3つのシーンタイプ（text, image, video）のサポート
- シンプルなアニメーションとトランジション
- CLIによる動画生成
- 基本的なエラーハンドリング

### v1.0
- 完全なアニメーション・トランジションセット
- 音声処理機能
- 包括的なテストカバレッジ
- 詳細なドキュメント

### 将来のバージョン
- AIナレーション機能（Gemini API統合）
- プラグインシステム
- Webインターフェース
- リアルタイムプレビュー

## リスクと対策

### 技術的リスク
1. **FFmpeg依存性**
   - 対策: 明確なインストールガイド、バージョン互換性テスト

2. **パフォーマンス問題**
   - 対策: プロファイリング、最適化、並列処理

3. **メモリ使用量**
   - 対策: ストリーミング処理、リソース制限

### スケジュールリスク
1. **機能の複雑性**
   - 対策: 段階的な実装、MVP優先

2. **テスト時間**
   - 対策: 自動化、CI/CD構築

## 成功指標

1. **機能面**
   - 3種類のシーンタイプが正常に動作
   - 基本的なアニメーションが適用可能
   - 複数シーンの結合が可能

2. **品質面**
   - テストカバレッジ80%以上
   - エラー時の適切なメッセージ表示
   - 1分の動画を30秒以内で生成

3. **ユーザビリティ**
   - 直感的なJSON構造
   - 明確なエラーメッセージ
   - 豊富なサンプルコード

## 実装の詳細タイムライン

### ステップ1: Validateコマンド（1-2日）
1. package.jsonとtsconfig.jsonの作成
2. 基本的なディレクトリ構造の構築
3. 型定義の実装
4. JSON parser/validatorの実装
5. validateコマンドの動作確認

### ステップ2: Previewコマンド（3-4日）
1. BaseSceneクラスの実装
2. Puppeteerサービスの構築
3. TextSceneの静止画生成
4. ImageSceneの静止画生成
5. previewコマンドの統合とテスト

### ステップ3: Generateコマンド（5-7日）
1. FFmpegラッパーの実装
2. 各シーンの動画化処理
3. アニメーション効果の実装
4. トランジション処理の実装
5. 動画結合とgenerateコマンドの完成

## 次のステップ

1. **即座に開始**: package.jsonとtsconfig.jsonの作成
2. **型定義の実装**: JSON構造に対応した TypeScript 型定義
3. **Validateの実装**: parser.ts と validator.ts の作成
4. **CLIの構築**: validateコマンドの動作確認

この段階的アプローチにより、各ステップで動作確認をしながら着実に機能を積み上げていきます。